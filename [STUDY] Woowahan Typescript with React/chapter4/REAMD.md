# 4장 타입 확장하기·좁히기

- [4장 타입 확장하기·좁히기](#4장-타입-확장하기좁히기)
  - [4.1 타입 확장하기](#41-타입-확장하기)
    - [4.1.1 타입 확장의 장점](#411-타입-확장의-장점)
    - [4.1.2 유니온 타입](#412-유니온-타입)
    - [4.1.3 교차 타입](#413-교차-타입)
    - [4.1.4 배달의 민족 메뉴 시스템에 타입 확장하기](#414-배달의-민족-메뉴-시스템에-타입-확장하기)
  - [4.2 타입 좁히기 - 타입 가드](#42-타입-좁히기---타입-가드)
    - [4.2.1 타입 가드에 따라 분기 처리하기](#421-타입-가드에-따라-분기-처리하기)
    - [4.2.2 원시 타입을 추론할때: typeof 연산자 활용하기](#422-원시-타입을-추론할때-typeof-연산자-활용하기)
    - [4.2.3 인스턴스화된 객체 타입을 판별할 때: instanceof 연산자 활용하기](#423-인스턴스화된-객체-타입을-판별할-때-instanceof-연산자-활용하기)
    - [4.2.4 객체의 속성이 있는지 없는지에 따른 구분: in 연산자 활용하기](#424-객체의-속성이-있는지-없는지에-따른-구분-in-연산자-활용하기)
    - [4.2.5 is 연산자로 사용자 정의 타입 가드 만들어 활용하기](#425-is-연산자로-사용자-정의-타입-가드-만들어-활용하기)
  - [4.3 타입 좁히기 - 식별할 수 있는 유니온](#43-타입-좁히기---식별할-수-있는-유니온)
    - [4.3.1 에러 정의하기](#431-에러-정의하기)
    - [4.3.2 식별할 수 있는 유니온](#432-식별할-수-있는-유니온)
    - [4.3.3 식별할 수 있는 유니온의 판별자 선정](#433-식별할-수-있는-유니온의-판별자-선정)
  - [4.4 Exhaustiveness Checking으로 정확한 타입 분기 유지하기](#44-exhaustiveness-checking으로-정확한-타입-분기-유지하기)
    - [4.4.1 상품권](#441-상품권)
  - [Keywords](#keywords)

<br>

## 4.1 타입 확장하기

### 4.1.1 타입 확장의 장점

### 4.1.2 유니온 타입

### 4.1.3 교차 타입

### 4.1.4 배달의 민족 메뉴 시스템에 타입 확장하기

<br>

## 4.2 타입 좁히기 - 타입 가드

### 4.2.1 타입 가드에 따라 분기 처리하기

### 4.2.2 원시 타입을 추론할때: typeof 연산자 활용하기

### 4.2.3 인스턴스화된 객체 타입을 판별할 때: instanceof 연산자 활용하기

### 4.2.4 객체의 속성이 있는지 없는지에 따른 구분: in 연산자 활용하기

### 4.2.5 is 연산자로 사용자 정의 타입 가드 만들어 활용하기

<br>

## 4.3 타입 좁히기 - 식별할 수 있는 유니온

### 4.3.1 에러 정의하기

### 4.3.2 식별할 수 있는 유니온

### 4.3.3 식별할 수 있는 유니온의 판별자 선정

<br>

## 4.4 Exhaustiveness Checking으로 정확한 타입 분기 유지하기

### 4.4.1 상품권

<br>

## Keywords
